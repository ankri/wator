{"version":3,"sources":["wator/tiles/OceanTileContent.ts","wator/tiles/LivingCreature.ts","wator/tiles/OceanTile.ts","wator/Direction.ts","wator/tiles/Animal.ts","wator/tiles/Plankton.ts","wator/tiles/Rock.ts","wator/Ocean.ts","wator/Simulation.ts","App.tsx","index.tsx"],"names":["OceanTileContent","type","progressSimulation","LivingCreature","tile","die","getTile","removeContent","setTile","newTile","OceanTile","coordinates","contents","isEmpty","length","hasContent","undefined","find","content","getContents","forEach","addContent","newContent","contentToRemove","filter","this","allDirections","Animal","age","weight","ageWhenAnimalIsDying","ageWhenAnimalIsBreeding","moveIntoTile","move","breed","getAge","tileToBreedInto","Ocean","getOcean","findNeighboringOceanTiles","weightOfFirstBornAnimal","Math","floor","getWeight","weightOfSecondBornAnimal","ceil","currentTile","Fish","Shark","gainWeight","possibleTilesToMoveInto","tileWithFish","beEaten","emptyTile","calculatePreferredDirection","random","tileToMoveTo","findOceanTileInDirection","fromCoordinates","inDirection","Plankton","Rock","parameters","oceanTiles","oceanDimensions","populateTile","parameterPopulation","randomNumber","bounds","lower","upper","fish","sharks","plankton","rocks","getOceanTiles","animals","flat","push","animal","direction","x","y","calculateNewCoordinatesInDirection","width","height","forCoordinates","map","dimensions","Array","row","column","population","oceanInstance","createOcean","Error","Simulation","ocean","createSimulation","simulation","Tile","oceanTile","className","classNames","water","shark","rock","createKey","index","join","App","React","useState","isSimulationRunning","setIsSimulationRunning","year","setYear","setOceanTiles","doProgressSimulation","useCallback","newField","useEffect","interval","setInterval","clearInterval","key","style","display","flexDirection","disabled","onClick","isRunning","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.5e6803e4.chunk.js","sourcesContent":["export type OceanTileContentType = 'plankton' | 'rock' | 'fish' | 'shark';\n\nexport abstract class OceanTileContent {\n  public abstract readonly type: OceanTileContentType;\n  public abstract progressSimulation: Function;\n}\n","import { OceanTile } from './OceanTile';\nimport { OceanTileContent } from './OceanTileContent';\n\nexport abstract class LivingCreature extends OceanTileContent {\n  private tile: OceanTile;\n\n  constructor({ tile }: { tile: OceanTile }) {\n    super();\n    this.tile = tile;\n  }\n\n  protected die = () => {\n    this.getTile().removeContent(this);\n  };\n\n  protected getTile = () => this.tile;\n  public setTile = (newTile: OceanTile) => {\n    this.tile = newTile;\n  };\n}\n","import { OceanCoordinates } from '../OceanCoordinates';\nimport { LivingCreature } from './LivingCreature';\nimport { OceanTileContent, OceanTileContentType } from './OceanTileContent';\n\nexport class OceanTile {\n  private contents: OceanTileContent[] = [];\n  public readonly coordinates: OceanCoordinates;\n\n  public constructor(coordinates: OceanCoordinates) {\n    this.coordinates = coordinates;\n  }\n\n  public isEmpty = (): boolean => {\n    return this.contents.length === 0 || this.hasContent('plankton');\n  };\n\n  public hasContent = (type: OceanTileContentType) => {\n    return this.contents.find(content => content.type === type) !== undefined;\n  };\n\n  public getContents = () => this.contents;\n\n  public progressSimulation = () => {\n    this.contents.forEach(content => content.progressSimulation());\n  };\n\n  public addContent = (newContent: OceanTileContent) => {\n    this.contents = [...this.contents, newContent];\n    if (newContent instanceof LivingCreature) {\n      newContent.setTile(this);\n    }\n  };\n\n  public removeContent = (contentToRemove: LivingCreature) => {\n    this.contents = this.contents.filter(\n      content => content !== contentToRemove\n    );\n  };\n}\n","export type Direction =\n  | 'NORTH'\n  | 'NORTH_EAST'\n  | 'EAST'\n  | 'SOUTH_EAST'\n  | 'SOUTH'\n  | 'SOUTH_WEST'\n  | 'WEST'\n  | 'NORTH_WEST';\n\nexport const allDirections: Direction[] = [\n  'NORTH',\n  'NORTH_EAST',\n  'EAST',\n  'SOUTH_EAST',\n  'SOUTH',\n  'SOUTH_WEST',\n  'WEST',\n  'NORTH_WEST'\n];\n","import { Ocean } from '../Ocean';\nimport { OceanTile } from './OceanTile';\nimport { LivingCreature } from './LivingCreature';\nimport { Direction } from '../Direction';\nimport { allDirections } from '../Direction';\nimport { Edible } from './Edible';\nimport { Plankton } from './Plankton';\n\nexport abstract class Animal extends LivingCreature {\n  private age: number;\n  private ageWhenAnimalIsDying: number;\n  private weight: number;\n  private ageWhenAnimalIsBreeding: number;\n\n  constructor({\n    age,\n    weight,\n    ageWhenAnimalIsDying,\n    ageWhenAnimalIsBreeding,\n    tile\n  }: {\n    age: number;\n    ageWhenAnimalIsDying: number;\n    ageWhenAnimalIsBreeding: number;\n    weight: number;\n    tile: OceanTile;\n  }) {\n    super({ tile });\n    this.age = age;\n    this.ageWhenAnimalIsDying = ageWhenAnimalIsDying;\n    this.ageWhenAnimalIsBreeding = ageWhenAnimalIsBreeding;\n    this.weight = weight;\n  }\n\n  protected moveIntoTile = (newTile: OceanTile) => {\n    this.getTile().removeContent(this);\n    newTile.addContent(this);\n  };\n\n  protected abstract move: Function;\n\n  protected breed = () => {\n    if (this.getAge() === this.ageWhenAnimalIsBreeding) {\n      const tileToBreedInto = Ocean.getOcean()\n        .findNeighboringOceanTiles(this.getTile().coordinates)\n        .find(tile => tile.isEmpty());\n\n      if (tileToBreedInto) {\n        const weightOfFirstBornAnimal = Math.floor(this.getWeight() / 2);\n        const weightOfSecondBornAnimal = Math.ceil(this.getWeight() / 2);\n        const currentTile = this.getTile();\n        this.die();\n        if (this.type === 'fish') {\n          currentTile.addContent(\n            new Fish({\n              tile: currentTile,\n              weight: weightOfFirstBornAnimal\n            })\n          );\n          tileToBreedInto.addContent(\n            new Fish({\n              tile: tileToBreedInto,\n              weight: weightOfSecondBornAnimal\n            })\n          );\n        } else if (this.type === 'shark') {\n          currentTile.addContent(\n            new Shark({\n              tile: currentTile,\n              weight: weightOfFirstBornAnimal\n            })\n          );\n          tileToBreedInto.addContent(\n            new Shark({\n              tile: tileToBreedInto,\n              weight: weightOfSecondBornAnimal\n            })\n          );\n        }\n      }\n    }\n  };\n\n  protected getAge = () => this.age;\n  protected getWeight = () => this.weight;\n\n  protected gainWeight = () => {\n    this.weight = this.weight + 1;\n  };\n\n  public progressSimulation = () => {\n    this.age = this.age + 1;\n    if (this.age === this.ageWhenAnimalIsDying) {\n      this.die();\n    } else {\n      this.move();\n      this.breed();\n\n      this.weight = this.weight - 1;\n\n      if (this.weight === 0) {\n        this.die();\n      }\n    }\n  };\n}\n\nexport class Shark extends Animal {\n  public readonly type = 'shark';\n\n  constructor({ tile, weight = 20 }: { tile: OceanTile; weight?: number }) {\n    super({\n      tile,\n      weight,\n      age: 1,\n      ageWhenAnimalIsDying: 20,\n      ageWhenAnimalIsBreeding: 15\n    });\n  }\n\n  protected move = () => {\n    const possibleTilesToMoveInto = Ocean.getOcean()\n      .findNeighboringOceanTiles(this.getTile().coordinates)\n      .filter(\n        tile =>\n          tile.hasContent('fish') ||\n          tile.hasContent('plankton') ||\n          tile.isEmpty()\n      );\n\n    if (\n      possibleTilesToMoveInto.find(tile => tile.hasContent('fish')) !==\n      undefined\n    ) {\n      const tileWithFish = possibleTilesToMoveInto.find(tile =>\n        tile.hasContent('fish')\n      ) as OceanTile;\n      (tileWithFish\n        .getContents()\n        .find(content => content.type === 'fish') as Fish).beEaten();\n      this.gainWeight();\n      this.moveIntoTile(tileWithFish);\n    } else {\n      const emptyTile = possibleTilesToMoveInto.find(tile => tile.isEmpty());\n\n      if (emptyTile !== undefined) {\n        this.moveIntoTile(emptyTile);\n      }\n    }\n  };\n}\n\nexport class Fish extends Animal implements Edible {\n  public readonly type = 'fish';\n\n  constructor({ tile, weight = 15 }: { tile: OceanTile; weight?: number }) {\n    super({\n      age: 1,\n      ageWhenAnimalIsDying: 15,\n      ageWhenAnimalIsBreeding: 12,\n      tile,\n      weight\n    });\n  }\n\n  private calculatePreferredDirection = (): Direction => {\n    return allDirections[Math.floor(Math.random() * allDirections.length)];\n  };\n\n  protected move = () => {\n    const tileToMoveTo = Ocean.getOcean().findOceanTileInDirection({\n      fromCoordinates: this.getTile().coordinates,\n      inDirection: this.calculatePreferredDirection()\n    });\n\n    if (tileToMoveTo !== null && tileToMoveTo.isEmpty()) {\n      this.moveIntoTile(tileToMoveTo);\n\n      if (tileToMoveTo.hasContent('plankton')) {\n        (tileToMoveTo\n          .getContents()\n          .find(content => content.type === 'plankton') as Plankton).beEaten();\n        this.gainWeight();\n      }\n    }\n  };\n\n  public beEaten = () => {\n    this.die();\n  };\n}\n","import { LivingCreature } from './LivingCreature';\nimport { OceanTile } from './OceanTile';\nimport { Edible } from './Edible';\n\nexport class Plankton extends LivingCreature implements Edible {\n  public readonly type = 'plankton';\n  public progressSimulation = () => {};\n\n  constructor({ tile }: { tile: OceanTile }) {\n    super({ tile });\n  }\n\n  public beEaten = () => {\n    this.die();\n  };\n}\n","import { OceanTileContent } from './OceanTileContent';\n\nexport class Rock extends OceanTileContent {\n  public readonly type = 'rock';\n  public progressSimulation = () => {};\n}\n","import { SimulationParameters } from './Simulation';\nimport { OceanTile } from './tiles/OceanTile';\nimport { Direction, allDirections } from './Direction';\nimport { OceanCoordinates } from './OceanCoordinates';\nimport { Fish, Shark } from './tiles/Animal';\nimport { Plankton } from './tiles/Plankton';\nimport { Rock } from './tiles/Rock';\nimport { Animal } from './tiles/Animal';\n\nfunction calculateNewCoordinatesInDirection(\n  coordinates: OceanCoordinates,\n  direction: Direction\n) {\n  const { x, y } = coordinates;\n  switch (direction) {\n    case 'NORTH':\n      return {\n        x,\n        y: y - 1\n      };\n    case 'NORTH_EAST':\n      return {\n        x: x + 1,\n        y: y - 1\n      };\n    case 'EAST':\n      return {\n        x: x + 1,\n        y\n      };\n    case 'SOUTH_EAST':\n      return {\n        x: x + 1,\n        y: y + 1\n      };\n    case 'SOUTH':\n      return {\n        x,\n        y: y + 1\n      };\n    case 'SOUTH_WEST':\n      return {\n        x: x - 1,\n        y: y + 1\n      };\n    case 'WEST':\n      return {\n        x: x - 1,\n        y\n      };\n    case 'NORTH_WEST':\n      return {\n        x: x - 1,\n        y: y - 1\n      };\n  }\n}\n\nexport class Ocean {\n  private oceanTiles: OceanTile[][];\n  private oceanDimensions: {\n    width: number;\n    height: number;\n  };\n  private static oceanInstance: Ocean;\n\n  private populateTile = (\n    tile: OceanTile,\n    parameterPopulation: SimulationParameters['population']\n  ) => {\n    const randomNumber = Math.floor(Math.random() * 100);\n    const bounds = {\n      fish: {\n        lower: 0,\n        upper: parameterPopulation.fish\n      },\n      sharks: {\n        lower: parameterPopulation.fish,\n        upper: parameterPopulation.fish + parameterPopulation.sharks\n      },\n      plankton: {\n        lower: parameterPopulation.fish + parameterPopulation.sharks,\n        upper:\n          parameterPopulation.fish +\n          parameterPopulation.sharks +\n          parameterPopulation.plankton\n      },\n      rocks: {\n        lower:\n          parameterPopulation.fish +\n          parameterPopulation.sharks +\n          parameterPopulation.plankton,\n        upper:\n          parameterPopulation.fish +\n          parameterPopulation.sharks +\n          parameterPopulation.plankton +\n          parameterPopulation.rocks\n      }\n    };\n\n    if (randomNumber > bounds.fish.lower && randomNumber <= bounds.fish.upper) {\n      tile.addContent(new Fish({ tile }));\n    } else if (\n      randomNumber > bounds.sharks.lower &&\n      randomNumber <= bounds.sharks.upper\n    ) {\n      tile.addContent(new Shark({ tile }));\n    } else if (\n      randomNumber > bounds.plankton.lower &&\n      randomNumber <= bounds.plankton.upper\n    ) {\n      tile.addContent(new Plankton({ tile }));\n    } else if (\n      randomNumber > bounds.rocks.lower &&\n      randomNumber <= bounds.rocks.upper\n    ) {\n      tile.addContent(new Rock());\n    }\n  };\n\n  private constructor(parameters: SimulationParameters) {\n    this.oceanDimensions = parameters.dimensions;\n    this.oceanTiles = new Array<OceanTile[]>();\n\n    for (let row = 0; row < this.oceanDimensions.height; row++) {\n      this.oceanTiles[row] = new Array<OceanTile>();\n      for (let column = 0; column < this.oceanDimensions.width; column++) {\n        const tile = new OceanTile({ x: column, y: row });\n        this.oceanTiles[row][column] = tile;\n        this.populateTile(tile, parameters.population);\n      }\n    }\n  }\n\n  public static createOcean = (parameters: SimulationParameters): Ocean => {\n    Ocean.oceanInstance = new Ocean(parameters);\n    return Ocean.oceanInstance;\n  };\n\n  public static getOcean = (): Ocean => {\n    if (Ocean.oceanInstance === null) {\n      throw new Error(\n        'You have to call createOcean before you can get an instance of Ocean'\n      );\n    } else {\n      return Ocean.oceanInstance;\n    }\n  };\n\n  public getOceanTiles = () => {\n    return this.oceanTiles;\n  };\n\n  public progressSimulation = () => {\n    const animals: Animal[] = [];\n    for (const tile of this.oceanTiles.flat()) {\n      for (const content of tile.getContents()) {\n        if (content.type === 'fish' || content.type === 'shark') {\n          animals.push(content as Animal);\n        }\n      }\n    }\n\n    animals.forEach(animal => {\n      animal.progressSimulation();\n    });\n\n    return this.oceanTiles;\n  };\n\n  public findOceanTileInDirection = ({\n    fromCoordinates,\n    inDirection\n  }: {\n    fromCoordinates: OceanCoordinates;\n    inDirection: Direction;\n  }): OceanTile | null => {\n    const { x, y } = calculateNewCoordinatesInDirection(\n      fromCoordinates,\n      inDirection\n    );\n\n    if (x < 0 || y < 0) {\n      return null;\n    } else if (\n      x >= this.oceanDimensions.width ||\n      y >= this.oceanDimensions.height\n    ) {\n      return null;\n    } else {\n      return this.oceanTiles[y][x];\n    }\n  };\n\n  public findNeighboringOceanTiles = (\n    forCoordinates: OceanCoordinates\n  ): OceanTile[] => {\n    return allDirections\n      .map(direction =>\n        this.findOceanTileInDirection({\n          fromCoordinates: forCoordinates,\n          inDirection: direction\n        })\n      )\n      .filter(tile => tile !== null) as OceanTile[];\n  };\n}\n","import { Ocean } from './Ocean';\nimport { OceanTile } from './tiles/OceanTile';\n\nexport interface SimulationParameters {\n  dimensions: {\n    width: number;\n    height: number;\n  };\n  population: {\n    fish: number;\n    sharks: number;\n    plankton: number;\n    rocks: number;\n  };\n}\n\nexport class Simulation {\n  private ocean: Ocean;\n\n  private constructor(parameters: SimulationParameters) {\n    this.ocean = Ocean.createOcean(parameters);\n  }\n\n  public static createSimulation = (\n    parameters: SimulationParameters\n  ): Simulation => {\n    return new Simulation(parameters);\n  };\n\n  public progressSimulation = (): OceanTile[][] => {\n    return this.ocean.progressSimulation();\n  };\n\n  public getOceanTiles = (): OceanTile[][] => {\n    return this.ocean.getOceanTiles();\n  };\n}\n","import React, { FunctionComponent } from 'react';\nimport { Simulation } from './wator/Simulation';\nimport { OceanTile } from './wator/tiles/OceanTile';\nimport classNames from 'classnames';\nimport './app.css';\n\nconst simulation = Simulation.createSimulation({\n  dimensions: {\n    width: 25,\n    height: 25\n  },\n  population: {\n    fish: 20,\n    sharks: 5,\n    plankton: 40,\n    rocks: 10\n  }\n});\n\nconst Tile: FunctionComponent<{ oceanTile: OceanTile }> = ({\n  oceanTile: tile\n}) => {\n  const className = classNames('tile', {\n    water: tile.isEmpty(),\n    plankton: tile.hasContent('plankton'),\n    fish: tile.hasContent('fish'),\n    shark: tile.hasContent('shark'),\n    rock: tile.hasContent('rock')\n  });\n\n  let content;\n  if (tile.hasContent('fish')) {\n    content = <>🐟</>;\n  } else if (tile.hasContent('shark')) {\n    content = <>🦈</>;\n  }\n\n  return <div className={className}>{content}</div>;\n};\n\nconst createKey = (index: number, tile: OceanTile) =>\n  `tile-${index}-${tile\n    .getContents()\n    .map(content => content.type)\n    .join('-')}`;\n\nconst App: FunctionComponent = () => {\n  const [isSimulationRunning, setIsSimulationRunning] = React.useState(false);\n  const [year, setYear] = React.useState(1);\n  const [oceanTiles, setOceanTiles] = React.useState<OceanTile[][]>(() =>\n    simulation.getOceanTiles()\n  );\n\n  const doProgressSimulation = React.useCallback(() => {\n    const newField = simulation.progressSimulation();\n    setOceanTiles(newField);\n    setYear(year => year + 1);\n  }, []);\n\n  React.useEffect(() => {\n    if (isSimulationRunning) {\n      const interval = setInterval(() => {\n        doProgressSimulation();\n      }, 350);\n\n      return () => {\n        clearInterval(interval);\n      };\n    }\n  }, [isSimulationRunning, doProgressSimulation]);\n\n  return (\n    <>\n      <div>\n        {oceanTiles.map((row, index) => (\n          <div\n            key={`row-${index}`}\n            style={{ display: 'flex', flexDirection: 'row' }}\n          >\n            {row.map((tile, index) => (\n              <Tile key={createKey(index, tile)} oceanTile={tile}></Tile>\n            ))}\n          </div>\n        ))}\n      </div>\n      <div>\n        <button\n          disabled={isSimulationRunning}\n          onClick={() => {\n            doProgressSimulation();\n          }}\n        >\n          progress by one step\n        </button>\n        <button\n          onClick={() => {\n            setIsSimulationRunning(isRunning => !isRunning);\n          }}\n        >\n          {isSimulationRunning ? 'stop simulation' : 'start simulation'}\n        </button>\n        <span>Year: {year}</span>\n      </div>\n    </>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}