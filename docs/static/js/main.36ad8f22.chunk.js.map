{"version":3,"sources":["wator/tiles/OceanTileContent.ts","wator/tiles/LivingCreature.ts","wator/tiles/OceanTile.ts","wator/Direction.ts","wator/tiles/Animal.ts","wator/tiles/Plankton.ts","wator/tiles/Rock.ts","wator/Ocean.ts","wator/Simulation.ts","App.tsx","index.tsx"],"names":["OceanTileContent","type","progressSimulation","LivingCreature","tile","die","getTile","removeContent","setTile","newTile","OceanTile","coordinates","contents","isEmpty","length","hasContent","undefined","find","content","getContents","forEach","addContent","newContent","contentToRemove","filter","this","allDirections","Animal","age","weight","ageWhenAnimalIsDying","ageWhenAnimalIsBreeding","moveIntoTile","move","breed","getAge","tileToBreedInto","Ocean","getOcean","findNeighboringOceanTiles","weightOfFirstBornAnimal","Math","floor","getWeight","weightOfSecondBornAnimal","ceil","currentTile","Fish","Shark","gainWeight","possibleTilesToMoveInto","tileWithFish","beEaten","emptyTile","preferredDirection","calculateMovementDirection","random","possibleTileToMoveTo","findOceanTileInDirection","fromCoordinates","inDirection","Plankton","Rock","parameters","oceanTiles","oceanDimensions","populateTile","parameterPopulation","randomNumber","bounds","lower","upper","fish","sharks","plankton","rocks","getOceanTiles","animals","flat","push","animal","direction","x","y","calculateNewCoordinatesInDirection","width","height","forCoordinates","map","dimensions","Array","row","column","population","oceanInstance","createOcean","Error","Simulation","ocean","createSimulation","simulation","Tile","oceanTile","className","classNames","water","shark","rock","createKey","index","join","App","React","useState","speed","setParameters","isSimulationRunning","setIsSimulationRunning","setYear","setOceanTiles","doProgressSimulation","useCallback","newField","year","useEffect","interval","setInterval","clearInterval","data","onUpdate","newParameters","title","closed","path","label","min","max","step","onClick","disabled","isRunning","key","style","display","flexDirection","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.36ad8f22.chunk.js","sourcesContent":["export type OceanTileContentType = 'plankton' | 'rock' | 'fish' | 'shark';\n\nexport abstract class OceanTileContent {\n  public abstract readonly type: OceanTileContentType;\n  public abstract progressSimulation: Function;\n}\n","import { OceanTile } from './OceanTile';\nimport { OceanTileContent } from './OceanTileContent';\n\nexport abstract class LivingCreature extends OceanTileContent {\n  private tile: OceanTile;\n\n  constructor({ tile }: { tile: OceanTile }) {\n    super();\n    this.tile = tile;\n  }\n\n  protected die = () => {\n    this.getTile().removeContent(this);\n  };\n\n  protected getTile = () => this.tile;\n  public setTile = (newTile: OceanTile) => {\n    this.tile = newTile;\n  };\n}\n","import { OceanCoordinates } from '../OceanCoordinates';\nimport { LivingCreature } from './LivingCreature';\nimport { OceanTileContent, OceanTileContentType } from './OceanTileContent';\n\nexport class OceanTile {\n  private contents: OceanTileContent[] = [];\n  public readonly coordinates: OceanCoordinates;\n\n  public constructor(coordinates: OceanCoordinates) {\n    this.coordinates = coordinates;\n  }\n\n  public isEmpty = (): boolean => {\n    return this.contents.length === 0 || this.hasContent('plankton');\n  };\n\n  public hasContent = (type: OceanTileContentType) => {\n    return this.contents.find(content => content.type === type) !== undefined;\n  };\n\n  public getContents = () => this.contents;\n\n  public progressSimulation = () => {\n    this.contents.forEach(content => content.progressSimulation());\n  };\n\n  public addContent = (newContent: OceanTileContent) => {\n    this.contents = [...this.contents, newContent];\n    if (newContent instanceof LivingCreature) {\n      newContent.setTile(this);\n    }\n  };\n\n  public removeContent = (contentToRemove: LivingCreature) => {\n    this.contents = this.contents.filter(\n      content => content !== contentToRemove\n    );\n  };\n}\n","export type Direction =\n  | 'NORTH'\n  | 'NORTH_EAST'\n  | 'EAST'\n  | 'SOUTH_EAST'\n  | 'SOUTH'\n  | 'SOUTH_WEST'\n  | 'WEST'\n  | 'NORTH_WEST';\n\nexport const allDirections: Direction[] = [\n  'NORTH',\n  'NORTH_EAST',\n  'EAST',\n  'SOUTH_EAST',\n  'SOUTH',\n  'SOUTH_WEST',\n  'WEST',\n  'NORTH_WEST'\n];\n","import { Ocean } from '../Ocean';\nimport { OceanTile } from './OceanTile';\nimport { LivingCreature } from './LivingCreature';\nimport { Direction } from '../Direction';\nimport { allDirections } from '../Direction';\nimport { Edible } from './Edible';\nimport { Plankton } from './Plankton';\n\nexport abstract class Animal extends LivingCreature {\n  private age: number;\n  private ageWhenAnimalIsDying: number;\n  private weight: number;\n  private ageWhenAnimalIsBreeding: number;\n\n  constructor({\n    age,\n    weight,\n    ageWhenAnimalIsDying,\n    ageWhenAnimalIsBreeding,\n    tile\n  }: {\n    age: number;\n    ageWhenAnimalIsDying: number;\n    ageWhenAnimalIsBreeding: number;\n    weight: number;\n    tile: OceanTile;\n  }) {\n    super({ tile });\n    this.age = age;\n    this.ageWhenAnimalIsDying = ageWhenAnimalIsDying;\n    this.ageWhenAnimalIsBreeding = ageWhenAnimalIsBreeding;\n    this.weight = weight;\n  }\n\n  protected moveIntoTile = (newTile: OceanTile) => {\n    this.getTile().removeContent(this);\n    newTile.addContent(this);\n  };\n\n  protected abstract move: Function;\n\n  protected breed = () => {\n    if (this.getAge() === this.ageWhenAnimalIsBreeding) {\n      const tileToBreedInto = Ocean.getOcean()\n        .findNeighboringOceanTiles(this.getTile().coordinates)\n        .find(tile => tile.isEmpty());\n\n      if (tileToBreedInto) {\n        const weightOfFirstBornAnimal = Math.floor(this.getWeight() / 2);\n        const weightOfSecondBornAnimal = Math.ceil(this.getWeight() / 2);\n        const currentTile = this.getTile();\n        this.die();\n        if (this.type === 'fish') {\n          currentTile.addContent(\n            new Fish({\n              tile: currentTile,\n              weight: weightOfFirstBornAnimal\n            })\n          );\n          tileToBreedInto.addContent(\n            new Fish({\n              tile: tileToBreedInto,\n              weight: weightOfSecondBornAnimal\n            })\n          );\n        } else if (this.type === 'shark') {\n          currentTile.addContent(\n            new Shark({\n              tile: currentTile,\n              weight: weightOfFirstBornAnimal\n            })\n          );\n          tileToBreedInto.addContent(\n            new Shark({\n              tile: tileToBreedInto,\n              weight: weightOfSecondBornAnimal\n            })\n          );\n        }\n      }\n    }\n  };\n\n  protected getAge = () => this.age;\n  protected getWeight = () => this.weight;\n\n  protected gainWeight = () => {\n    this.weight = this.weight + 1;\n  };\n\n  public progressSimulation = () => {\n    this.age = this.age + 1;\n    if (this.age === this.ageWhenAnimalIsDying) {\n      this.die();\n    } else {\n      this.move();\n      this.breed();\n\n      this.weight = this.weight - 1;\n\n      if (this.weight === 0) {\n        this.die();\n      }\n    }\n  };\n}\n\nexport class Shark extends Animal {\n  public readonly type = 'shark';\n\n  constructor({ tile, weight = 20 }: { tile: OceanTile; weight?: number }) {\n    super({\n      tile,\n      weight,\n      age: 1,\n      ageWhenAnimalIsDying: 20,\n      ageWhenAnimalIsBreeding: 15\n    });\n  }\n\n  protected move = () => {\n    const possibleTilesToMoveInto = Ocean.getOcean()\n      .findNeighboringOceanTiles(this.getTile().coordinates)\n      .filter(\n        tile =>\n          tile.hasContent('fish') ||\n          tile.hasContent('plankton') ||\n          tile.isEmpty()\n      );\n\n    if (\n      possibleTilesToMoveInto.find(tile => tile.hasContent('fish')) !==\n      undefined\n    ) {\n      const tileWithFish = possibleTilesToMoveInto.find(tile =>\n        tile.hasContent('fish')\n      ) as OceanTile;\n      (tileWithFish\n        .getContents()\n        .find(content => content.type === 'fish') as Fish).beEaten();\n      this.gainWeight();\n      this.moveIntoTile(tileWithFish);\n    } else {\n      const emptyTile = possibleTilesToMoveInto.find(tile => tile.isEmpty());\n\n      if (emptyTile !== undefined) {\n        this.moveIntoTile(emptyTile);\n      }\n    }\n  };\n}\n\nexport class Fish extends Animal implements Edible {\n  public readonly type = 'fish';\n  private preferredDirection: Direction;\n\n  constructor({ tile, weight = 15 }: { tile: OceanTile; weight?: number }) {\n    super({\n      age: 1,\n      ageWhenAnimalIsDying: 15,\n      ageWhenAnimalIsBreeding: 12,\n      tile,\n      weight\n    });\n\n    this.preferredDirection =\n      allDirections[Math.floor(Math.random() * allDirections.length)];\n  }\n\n  private calculateMovementDirection = (): Direction => {\n    return [...allDirections, this.preferredDirection][\n      Math.floor(Math.random() * allDirections.length + 1)\n    ];\n  };\n\n  protected move = () => {\n    const possibleTileToMoveTo = Ocean.getOcean().findOceanTileInDirection({\n      fromCoordinates: this.getTile().coordinates,\n      inDirection: this.calculateMovementDirection()\n    });\n\n    if (possibleTileToMoveTo !== null && possibleTileToMoveTo.isEmpty()) {\n      this.moveIntoTile(possibleTileToMoveTo);\n\n      if (possibleTileToMoveTo.hasContent('plankton')) {\n        (possibleTileToMoveTo\n          .getContents()\n          .find(content => content.type === 'plankton') as Plankton).beEaten();\n        this.gainWeight();\n      }\n    }\n  };\n\n  public beEaten = () => {\n    this.die();\n  };\n}\n","import { LivingCreature } from './LivingCreature';\nimport { OceanTile } from './OceanTile';\nimport { Edible } from './Edible';\n\nexport class Plankton extends LivingCreature implements Edible {\n  public readonly type = 'plankton';\n  public progressSimulation = () => {};\n\n  constructor({ tile }: { tile: OceanTile }) {\n    super({ tile });\n  }\n\n  public beEaten = () => {\n    this.die();\n  };\n}\n","import { OceanTileContent } from './OceanTileContent';\n\nexport class Rock extends OceanTileContent {\n  public readonly type = 'rock';\n  public progressSimulation = () => {};\n}\n","import { SimulationParameters } from './Simulation';\nimport { OceanTile } from './tiles/OceanTile';\nimport { Direction, allDirections } from './Direction';\nimport { OceanCoordinates } from './OceanCoordinates';\nimport { Fish, Shark } from './tiles/Animal';\nimport { Plankton } from './tiles/Plankton';\nimport { Rock } from './tiles/Rock';\nimport { Animal } from './tiles/Animal';\n\nfunction calculateNewCoordinatesInDirection(\n  coordinates: OceanCoordinates,\n  direction: Direction\n) {\n  const { x, y } = coordinates;\n  switch (direction) {\n    case 'NORTH':\n      return {\n        x,\n        y: y - 1\n      };\n    case 'NORTH_EAST':\n      return {\n        x: x + 1,\n        y: y - 1\n      };\n    case 'EAST':\n      return {\n        x: x + 1,\n        y\n      };\n    case 'SOUTH_EAST':\n      return {\n        x: x + 1,\n        y: y + 1\n      };\n    case 'SOUTH':\n      return {\n        x,\n        y: y + 1\n      };\n    case 'SOUTH_WEST':\n      return {\n        x: x - 1,\n        y: y + 1\n      };\n    case 'WEST':\n      return {\n        x: x - 1,\n        y\n      };\n    case 'NORTH_WEST':\n      return {\n        x: x - 1,\n        y: y - 1\n      };\n  }\n}\n\nexport class Ocean {\n  private oceanTiles: OceanTile[][];\n  private oceanDimensions: {\n    width: number;\n    height: number;\n  };\n  private static oceanInstance: Ocean;\n\n  private populateTile = (\n    tile: OceanTile,\n    parameterPopulation: SimulationParameters['population']\n  ) => {\n    const randomNumber = Math.floor(Math.random() * 100);\n    const bounds = {\n      fish: {\n        lower: 0,\n        upper: parameterPopulation.fish\n      },\n      sharks: {\n        lower: parameterPopulation.fish,\n        upper: parameterPopulation.fish + parameterPopulation.sharks\n      },\n      plankton: {\n        lower: parameterPopulation.fish + parameterPopulation.sharks,\n        upper:\n          parameterPopulation.fish +\n          parameterPopulation.sharks +\n          parameterPopulation.plankton\n      },\n      rocks: {\n        lower:\n          parameterPopulation.fish +\n          parameterPopulation.sharks +\n          parameterPopulation.plankton,\n        upper:\n          parameterPopulation.fish +\n          parameterPopulation.sharks +\n          parameterPopulation.plankton +\n          parameterPopulation.rocks\n      }\n    };\n\n    if (randomNumber > bounds.fish.lower && randomNumber <= bounds.fish.upper) {\n      tile.addContent(new Fish({ tile }));\n    } else if (\n      randomNumber > bounds.sharks.lower &&\n      randomNumber <= bounds.sharks.upper\n    ) {\n      tile.addContent(new Shark({ tile }));\n    } else if (\n      randomNumber > bounds.plankton.lower &&\n      randomNumber <= bounds.plankton.upper\n    ) {\n      tile.addContent(new Plankton({ tile }));\n    } else if (\n      randomNumber > bounds.rocks.lower &&\n      randomNumber <= bounds.rocks.upper\n    ) {\n      tile.addContent(new Rock());\n    }\n  };\n\n  private constructor(parameters: SimulationParameters) {\n    this.oceanDimensions = parameters.dimensions;\n    this.oceanTiles = new Array<OceanTile[]>();\n\n    for (let row = 0; row < this.oceanDimensions.height; row++) {\n      this.oceanTiles[row] = new Array<OceanTile>();\n      for (let column = 0; column < this.oceanDimensions.width; column++) {\n        const tile = new OceanTile({ x: column, y: row });\n        this.oceanTiles[row][column] = tile;\n        this.populateTile(tile, parameters.population);\n      }\n    }\n  }\n\n  public static createOcean = (parameters: SimulationParameters): Ocean => {\n    Ocean.oceanInstance = new Ocean(parameters);\n    return Ocean.oceanInstance;\n  };\n\n  public static getOcean = (): Ocean => {\n    if (Ocean.oceanInstance === null) {\n      throw new Error(\n        'You have to call createOcean before you can get an instance of Ocean'\n      );\n    } else {\n      return Ocean.oceanInstance;\n    }\n  };\n\n  public getOceanTiles = () => {\n    return this.oceanTiles;\n  };\n\n  public progressSimulation = () => {\n    const animals: Animal[] = [];\n    for (const tile of this.oceanTiles.flat()) {\n      for (const content of tile.getContents()) {\n        if (content.type === 'fish' || content.type === 'shark') {\n          animals.push(content as Animal);\n        }\n      }\n    }\n\n    animals.forEach(animal => {\n      animal.progressSimulation();\n    });\n\n    return this.oceanTiles;\n  };\n\n  public findOceanTileInDirection = ({\n    fromCoordinates,\n    inDirection\n  }: {\n    fromCoordinates: OceanCoordinates;\n    inDirection: Direction;\n  }): OceanTile | null => {\n    const { x, y } = calculateNewCoordinatesInDirection(\n      fromCoordinates,\n      inDirection\n    );\n\n    if (x < 0 || y < 0) {\n      return null;\n    } else if (\n      x >= this.oceanDimensions.width ||\n      y >= this.oceanDimensions.height\n    ) {\n      return null;\n    } else {\n      return this.oceanTiles[y][x];\n    }\n  };\n\n  public findNeighboringOceanTiles = (\n    forCoordinates: OceanCoordinates\n  ): OceanTile[] => {\n    return allDirections\n      .map(direction =>\n        this.findOceanTileInDirection({\n          fromCoordinates: forCoordinates,\n          inDirection: direction\n        })\n      )\n      .filter(tile => tile !== null) as OceanTile[];\n  };\n}\n","import { Ocean } from './Ocean';\nimport { OceanTile } from './tiles/OceanTile';\n\nexport interface SimulationParameters {\n  dimensions: {\n    width: number;\n    height: number;\n  };\n  population: {\n    fish: number;\n    sharks: number;\n    plankton: number;\n    rocks: number;\n  };\n}\n\nexport class Simulation {\n  private ocean: Ocean;\n\n  private constructor(parameters: SimulationParameters) {\n    this.ocean = Ocean.createOcean(parameters);\n  }\n\n  public static createSimulation = (\n    parameters: SimulationParameters\n  ): Simulation => {\n    return new Simulation(parameters);\n  };\n\n  public progressSimulation = (): OceanTile[][] => {\n    return this.ocean.progressSimulation();\n  };\n\n  public getOceanTiles = (): OceanTile[][] => {\n    return this.ocean.getOceanTiles();\n  };\n}\n","import React, { FunctionComponent } from 'react';\nimport DatGui, { DatButton, DatNumber, DatFolder } from 'react-dat-gui';\nimport 'react-dat-gui/dist/index.css';\nimport { Simulation, SimulationParameters } from './wator/Simulation';\nimport { OceanTile } from './wator/tiles/OceanTile';\nimport classNames from 'classnames';\nimport './app.css';\n\nlet simulation = Simulation.createSimulation({\n  dimensions: {\n    width: 25,\n    height: 25\n  },\n  population: {\n    fish: 20,\n    sharks: 5,\n    plankton: 40,\n    rocks: 10\n  }\n});\n\nconst Tile: FunctionComponent<{ oceanTile: OceanTile }> = ({\n  oceanTile: tile\n}) => {\n  const className = classNames('tile', {\n    water: tile.isEmpty(),\n    plankton: tile.hasContent('plankton'),\n    fish: tile.hasContent('fish'),\n    shark: tile.hasContent('shark'),\n    rock: tile.hasContent('rock')\n  });\n\n  let content;\n  if (tile.hasContent('fish')) {\n    content = <>🐟</>;\n  } else if (tile.hasContent('shark')) {\n    content = <>🦈</>;\n  }\n\n  return <div className={className}>{content}</div>;\n};\n\nconst createKey = (index: number, tile: OceanTile) =>\n  `tile-${index}-${tile\n    .getContents()\n    .map(content => content.type)\n    .join('-')}`;\n\nconst App: FunctionComponent = () => {\n  const [parameters, setParameters] = React.useState<\n    SimulationParameters & { simulation: { speed: number } }\n  >(() => ({\n    dimensions: {\n      width: 25,\n      height: 25\n    },\n    population: {\n      fish: 20,\n      sharks: 10,\n      plankton: 30,\n      rocks: 5\n    },\n    simulation: {\n      speed: 350\n    }\n  }));\n  const [isSimulationRunning, setIsSimulationRunning] = React.useState(false);\n  const [year, setYear] = React.useState(1);\n  const [oceanTiles, setOceanTiles] = React.useState<OceanTile[][]>(() =>\n    simulation.getOceanTiles()\n  );\n\n  const doProgressSimulation = React.useCallback(() => {\n    const newField = simulation.progressSimulation();\n    setOceanTiles(newField);\n    setYear(year => year + 1);\n  }, []);\n\n  React.useEffect(() => {\n    if (isSimulationRunning) {\n      const interval = setInterval(() => {\n        doProgressSimulation();\n      }, parameters.simulation.speed);\n\n      return () => {\n        clearInterval(interval);\n      };\n    }\n  }, [isSimulationRunning, doProgressSimulation, parameters]);\n\n  return (\n    <>\n      <DatGui\n        data={parameters}\n        onUpdate={(\n          newParameters: SimulationParameters & {\n            simulation: { speed: number };\n          }\n        ) => {\n          setParameters(newParameters);\n        }}\n      >\n        <DatFolder title=\"Dimensions\" closed={false}>\n          <DatNumber\n            path=\"dimensions.width\"\n            label=\"Width\"\n            min={20}\n            max={50}\n            step={1}\n          />\n          <DatNumber\n            path=\"dimensions.height\"\n            label=\"Height\"\n            min={20}\n            max={50}\n            step={1}\n          />\n        </DatFolder>\n        <DatFolder title=\"Population\" closed={false}>\n          <DatNumber\n            path=\"population.fish\"\n            label=\"% Fishes\"\n            min={1}\n            max={100}\n            step={1}\n          />\n          <DatNumber\n            path=\"population.sharks\"\n            label=\"% Sharks\"\n            min={1}\n            max={100}\n            step={1}\n          />\n          <DatNumber\n            path=\"population.plankton\"\n            label=\"% Plankton\"\n            min={1}\n            max={100}\n            step={1}\n          />\n          <DatNumber\n            path=\"population.rocks\"\n            label=\"% Rocks\"\n            min={1}\n            max={100}\n            step={1}\n          />\n        </DatFolder>\n        <DatFolder title=\"Simulation\">\n          <DatNumber\n            path=\"simulation.speed\"\n            label=\"Speed in ms\"\n            min={100}\n            max={5000}\n            step={100}\n          />\n        </DatFolder>\n\n        <DatButton\n          onClick={() => {\n            setIsSimulationRunning(false);\n            simulation = Simulation.createSimulation(parameters);\n            setOceanTiles(simulation.getOceanTiles());\n            setYear(1);\n          }}\n          label=\"Restart with new Parameters\"\n        ></DatButton>\n        <DatButton\n          disabled={isSimulationRunning}\n          onClick={() => {\n            doProgressSimulation();\n          }}\n          label=\"Progress Simulation\"\n        ></DatButton>\n        <DatButton\n          onClick={() => {\n            setIsSimulationRunning(isRunning => !isRunning);\n          }}\n          label={isSimulationRunning ? 'stop simulation' : 'start simulation'}\n        ></DatButton>\n      </DatGui>\n\n      <div>\n        {oceanTiles.map((row, index) => (\n          <div\n            key={`row-${index}`}\n            style={{ display: 'flex', flexDirection: 'row' }}\n          >\n            {row.map((tile, index) => (\n              <Tile key={createKey(index, tile)} oceanTile={tile}></Tile>\n            ))}\n          </div>\n        ))}\n      </div>\n    </>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}